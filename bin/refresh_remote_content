#!/usr/bin/env ruby

# Scripts that downloads the dynamic changelogs for components a well as librdkafka releases info

require 'fileutils'
require 'net/http'
require 'json'

# Configuration for changelog sources
CHANGELOGS = {
  'Karafka' => "https://raw.githubusercontent.com/karafka/karafka/master/CHANGELOG.md",
  'WaterDrop' => "https://raw.githubusercontent.com/karafka/waterdrop/master/CHANGELOG.md",
  'Karafka-Web-UI' => "https://raw.githubusercontent.com/karafka/karafka-web/master/CHANGELOG.md",
  'Karafka-Testing' => "https://raw.githubusercontent.com/karafka/karafka-testing/master/CHANGELOG.md",
  'Karafka-Core' => "https://raw.githubusercontent.com/karafka/karafka-core/master/CHANGELOG.md",
  'Karafka-Rdkafka' => "https://raw.githubusercontent.com/karafka/karafka-rdkafka/master/CHANGELOG.md",
  'Rdkafka' => "https://raw.githubusercontent.com/karafka/rdkafka-ruby/master/CHANGELOG.md"
}

# Default output directory - can be overridden via command line
DEFAULT_OUTPUT_DIR = '.'

class ChangelogFetcher
  def initialize(output_dir = DEFAULT_OUTPUT_DIR)
    @output_dir = output_dir
    ensure_output_directory
  end

  def fetch_all
    puts "Fetching changelogs to #{@output_dir}..."

    CHANGELOGS.each do |name, url|
      fetch_changelog(name, url)
    end

    fetch_librdkafka_changelog

    puts "Done! Fetched #{CHANGELOGS.size + 1} changelogs."
  end

  private

  def ensure_output_directory
    FileUtils.mkdir_p(@output_dir) unless Dir.exist?(@output_dir)
    FileUtils.mkdir_p(File.join(@output_dir, 'Changelog')) unless Dir.exist?(File.join(@output_dir, 'Changelog'))
    FileUtils.mkdir_p(File.join(@output_dir, 'Librdkafka')) unless Dir.exist?(File.join(@output_dir, 'Librdkafka'))
  end

  def fetch_changelog(name, url)
    output_file = File.join(@output_dir, "Changelog", "#{name}.md")

    puts "Fetching #{name} changelog..."

    system("curl -H 'Accept-Encoding: deflate' -o '#{output_file}' '#{url}'")

    if $?.success?
      add_auto_generated_comment(output_file)
      puts "  ✓ Saved to #{output_file}"
    else
      puts "  ✗ Failed to fetch #{name} changelog"
    end
  end

  def fetch_librdkafka_changelog
    puts "Fetching librdkafka changelog..."

    begin
      url = 'https://api.github.com/repos/confluentinc/librdkafka/releases'
      releases = fetch_releases(url)
      markdown_content = generate_librdkafka_markdown(releases)

      output_file = File.join(@output_dir, 'Librdkafka', 'Changelog.md')
      save_librdkafka_changelog(markdown_content, output_file)

      puts "  ✓ Saved to #{output_file}"
    rescue => e
      puts "  ✗ Failed to fetch librdkafka changelog: #{e.message}"
    end
  end

  def fetch_releases(url)
    uri = URI(url)
    response = Net::HTTP.get(uri)
    JSON.parse(response)
  end

  def format_release(release)
    version = release['tag_name'].gsub('v', '')
    published_at = release['published_at'].split('T').first
    body = release['body']

    # Adjust heading levels
    body.gsub!(/^######\s/, '####### ')
    body.gsub!(/^#####\s/, '###### ')
    body.gsub!(/^####\s/, '##### ')
    body.gsub!(/^###\s/, '#### ')
    body.gsub!(/^##\s/, '### ')

    <<~MARKDOWN
## #{version} (#{published_at})

#{body}
    MARKDOWN
  end

  def generate_librdkafka_markdown(releases)
    markdown = ""
    releases.each do |release|
      markdown += format_release(release)
    end
    markdown
  end

  def save_librdkafka_changelog(content, filename)
    File.open(filename, 'w') do |file|
      file.write <<~MSG
[//]: # (This file is auto-generated by bin/refresh_remote_content)
[//]: # (Do not edit manually - changes will be overwritten)

# Librdkafka Changelog

!!! note ""
    This page is a copy of the [releases](https://github.com/confluentinc/librdkafka/releases) of `librdkafka`.

MSG
      file.write(content)
    end
  end

  def add_auto_generated_comment(file_path)
    # Read the original content
    original_content = File.read(file_path, encoding: 'utf-8')

    # Add the comment at the top
    commented_content = <<~COMMENT
[//]: # (This file is auto-generated by bin/refresh_remote_content)
[//]: # (Do not edit manually - changes will be overwritten)

#{original_content}
COMMENT
    # Write back to the file with explicit encoding
    File.write(file_path, commented_content, encoding: 'utf-8')
  end
end

# Script execution
if __FILE__ == $0
  output_dir = ARGV[0] || DEFAULT_OUTPUT_DIR

  fetcher = ChangelogFetcher.new(output_dir)
  fetcher.fetch_all
end

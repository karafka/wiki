#!/usr/bin/env ruby

# Script that fetches instrumentation events from Karafka ecosystem components
# and generates documentation pages listing all available events

require 'fileutils'

# Configuration for instrumentation sources
INSTRUMENTATION_SOURCES = {
  'Karafka' => {
    url: 'https://raw.githubusercontent.com/karafka/karafka/master/lib/karafka/instrumentation/notifications.rb',
    output_file: 'Operations/Instrumentation-Events.md',
    title: 'Karafka Instrumentation Events'
  },
  'WaterDrop' => {
    url: 'https://raw.githubusercontent.com/karafka/waterdrop/master/lib/waterdrop/instrumentation/notifications.rb',
    output_file: 'WaterDrop/Instrumentation-Events.md',
    title: 'WaterDrop Instrumentation Events'
  }
}

# Default output directory
DEFAULT_OUTPUT_DIR = '.'

class InstrumentationFetcher
  def initialize(output_dir = DEFAULT_OUTPUT_DIR)
    @output_dir = output_dir
    ensure_output_directory
  end

  def fetch_all
    puts "Fetching instrumentation events to #{@output_dir}..."

    INSTRUMENTATION_SOURCES.each do |component, config|
      fetch_and_generate(component, config)
    end

    puts "Done! Generated #{INSTRUMENTATION_SOURCES.size} instrumentation documentation pages."
  end

  private

  def ensure_output_directory
    FileUtils.mkdir_p(@output_dir) unless Dir.exist?(@output_dir)
    FileUtils.mkdir_p(File.join(@output_dir, 'WaterDrop')) unless Dir.exist?(File.join(@output_dir, 'WaterDrop'))
  end

  def fetch_and_generate(component, config)
    puts "Fetching #{component} instrumentation events..."

    # Fetch the source file
    temp_file = "/tmp/#{component.downcase}_notifications.rb"
    system("curl -sS -f -H 'Accept-Encoding: deflate' -o '#{temp_file}' '#{config[:url]}'")

    unless $?.success?
      puts "Failed to fetch #{component} instrumentation events"
      raise "Curl failed with exit code #{$?.exitstatus} for #{config[:url]}"
    end

    # Parse events from the file
    events = parse_events(temp_file)

    if events.empty?
      puts "No events found in #{component} notifications"
      File.delete(temp_file) if File.exist?(temp_file)
      raise "No events found in #{component} notifications file"
    end

    # Generate documentation
    output_file = File.join(@output_dir, config[:output_file])
    generate_documentation(component, events, config[:title], output_file)

    # Clean up
    File.delete(temp_file) if File.exist?(temp_file)

    puts "Generated #{output_file} with #{events.size} events"
  end

  def parse_events(file_path)
    content = File.read(file_path, encoding: 'utf-8')

    # Extract the EVENTS array
    if content =~ /EVENTS\s*=\s*%w\[(.*?)\]/m
      events_text = $1
      events = events_text.scan(/[\w.]+/).map(&:strip).reject(&:empty?)
      return events
    end

    []
  end

  def generate_documentation(component, events, title, output_file)
    content = <<~MARKDOWN
[//]: # (This file is auto-generated by bin/refresh_instrumentation_events)
[//]: # (Do not edit manually - changes will be overwritten)

# #{title}

This page lists all available instrumentation events for #{component}.

## Overview

#{component} uses a notification system that allows you to monitor and hook into various stages of message processing and producer operations. You can subscribe to any of these events to add custom monitoring, logging, or other functionality.

## Available Events

Below is the complete list of instrumentation events available in #{component}:

MARKDOWN

    # Group events by namespace
    grouped_events = events.group_by { |event| event.split('.').first }

    grouped_events.sort.each do |namespace, namespace_events|
      content += "\n### #{namespace.capitalize} Events\n\n"
      namespace_events.sort.each do |event|
        content += "- `#{event}`\n"
      end
    end

    content += <<~MARKDOWN

## Usage Example

To subscribe to any of these events, you can use the instrumentation monitor:

```ruby
#{component}::App.monitor.subscribe('event.name') do |event|
  # Your custom logic here
  puts "Event: \#{event.id}"
  puts "Payload: \#{event.payload}"
end
```

For more information about using instrumentation, please refer to the main documentation.
MARKDOWN

    # Write the file with explicit encoding
    File.write(output_file, content, encoding: 'utf-8')
  end
end

# Script execution
if __FILE__ == $0
  output_dir = ARGV[0] || DEFAULT_OUTPUT_DIR

  fetcher = InstrumentationFetcher.new(output_dir)
  fetcher.fetch_all
end

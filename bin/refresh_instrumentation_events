#!/usr/bin/env ruby

# Script that fetches instrumentation events from Karafka ecosystem components
# and generates documentation pages listing all available events

require 'fileutils'

# Configuration for instrumentation sources
INSTRUMENTATION_SOURCES = {
  'Karafka' => {
    url: 'https://raw.githubusercontent.com/karafka/karafka/master/lib/karafka/instrumentation/notifications.rb',
    output_file: 'Operations/Instrumentation-Events.md',
    title: 'Karafka Instrumentation Events'
  },
  'WaterDrop' => {
    url: 'https://raw.githubusercontent.com/karafka/waterdrop/master/lib/waterdrop/instrumentation/notifications.rb',
    class_url: 'https://raw.githubusercontent.com/karafka/waterdrop/master/lib/waterdrop/instrumentation/class_notifications.rb',
    output_file: 'WaterDrop/Instrumentation-Events.md',
    title: 'WaterDrop Instrumentation Events'
  }
}

# Default output directory
DEFAULT_OUTPUT_DIR = '.'

class InstrumentationFetcher
  def initialize(output_dir = DEFAULT_OUTPUT_DIR)
    @output_dir = output_dir
    ensure_output_directory
  end

  def fetch_all
    puts "Fetching instrumentation events to #{@output_dir}..."

    INSTRUMENTATION_SOURCES.each do |component, config|
      fetch_and_generate(component, config)
    end

    puts "Done! Generated #{INSTRUMENTATION_SOURCES.size} instrumentation documentation pages."
  end

  private

  def ensure_output_directory
    FileUtils.mkdir_p(@output_dir) unless Dir.exist?(@output_dir)
    FileUtils.mkdir_p(File.join(@output_dir, 'WaterDrop')) unless Dir.exist?(File.join(@output_dir, 'WaterDrop'))
  end

  def fetch_and_generate(component, config)
    puts "Fetching #{component} instrumentation events..."

    # Fetch the source file
    temp_file = "/tmp/#{component.downcase}_notifications.rb"
    system("curl -sS -f -H 'Accept-Encoding: deflate' -o '#{temp_file}' '#{config[:url]}'")

    unless $?.success?
      puts "Failed to fetch #{component} instrumentation events"
      raise "Curl failed with exit code #{$?.exitstatus} for #{config[:url]}"
    end

    # Parse events from the file
    events = parse_events(temp_file)

    if events.empty?
      puts "No events found in #{component} notifications"
      File.delete(temp_file) if File.exist?(temp_file)
      raise "No events found in #{component} notifications file"
    end

    # Clean up main temp file
    File.delete(temp_file) if File.exist?(temp_file)

    # Fetch class-level events if configured
    class_events = []
    if config[:class_url]
      class_temp_file = "/tmp/#{component.downcase}_class_notifications.rb"
      system("curl -sS -f -H 'Accept-Encoding: deflate' -o '#{class_temp_file}' '#{config[:class_url]}'")

      if $?.success?
        class_events = parse_events(class_temp_file)
        puts "Found #{class_events.size} class-level events" unless class_events.empty?
      end

      File.delete(class_temp_file) if File.exist?(class_temp_file)
    end

    # Generate documentation
    output_file = File.join(@output_dir, config[:output_file])
    generate_documentation(component, events, config[:title], output_file, class_events)

    puts "Generated #{output_file} with #{events.size} instance events#{class_events.empty? ? '' : " and #{class_events.size} class-level events"}"
  end

  def parse_events(file_path)
    content = File.read(file_path, encoding: 'utf-8')

    # Extract the EVENTS array
    if content =~ /EVENTS\s*=\s*%w\[(.*?)\]/m
      events_text = $1
      events = events_text.scan(/[\w.]+/).map(&:strip).reject(&:empty?)
      return events
    end

    []
  end

  def generate_documentation(component, events, title, output_file, class_events = [])
    content = <<~MARKDOWN
[//]: # (This file is auto-generated by bin/refresh_instrumentation_events)
[//]: # (Do not edit manually - changes will be overwritten)

# #{title}

This page lists all available instrumentation events for #{component}.

## Overview

#{component} uses a notification system that allows you to monitor and hook into various stages of message processing and producer operations. You can subscribe to any of these events to add custom monitoring, logging, or other functionality.

## Available Events

Below is the complete list of instrumentation events available in #{component}:

MARKDOWN

    # Group events by namespace
    grouped_events = events.group_by { |event| event.split('.').first }

    grouped_events.sort.each do |namespace, namespace_events|
      content += "\n### #{namespace.capitalize} Events\n\n"
      namespace_events.sort.each do |event|
        content += "- `#{event}`\n"
      end
    end

    content += <<~MARKDOWN

## Usage Example

To subscribe to any of these events, you can use the instrumentation monitor:

```ruby
#{component}::App.monitor.subscribe('event.name') do |event|
  # Your custom logic here
  puts "Event: \#{event.id}"
  puts "Payload: \#{event.payload}"
end
```

For more information about using instrumentation, please refer to the main documentation.
MARKDOWN

    # Add class-level events section if available
    unless class_events.empty?
      content += <<~MARKDOWN

## Class-Level Events

#{component} also provides class-level instrumentation that allows you to monitor events across all producer instances. This is useful for external libraries and monitoring tools that need to hook into producer lifecycle events without requiring specific producer instance references.

### Available Class-Level Events

MARKDOWN

      # Group class events by namespace
      grouped_class_events = class_events.group_by { |event| event.split('.').first }

      grouped_class_events.sort.each do |namespace, namespace_events|
        content += "\n#### #{namespace.capitalize} Events\n\n"
        namespace_events.sort.each do |event|
          content += "- `#{event}`\n"
        end
      end

      content += <<~MARKDOWN

### Class-Level Event Payloads

| Event | Payload Keys | Description |
|-------|--------------|-------------|
| `connection_pool.created` | `connection_pool`, `connection_pool_id` | Triggered when a new connection pool is created |
| `connection_pool.reload` | `connection_pool`, `connection_pool_id` | Triggered before a connection pool reloads its connections |
| `connection_pool.reloaded` | `connection_pool`, `connection_pool_id` | Triggered after a connection pool has reloaded its connections |
| `connection_pool.setup` | `connection_pool`, `connection_pool_id` | Triggered when a connection pool is being set up |
| `connection_pool.shutdown` | `connection_pool`, `connection_pool_id` | Triggered when a connection pool is shutting down |
| `producer.created` | `producer`, `producer_id` | Triggered when a new producer instance is instantiated, before configuration |
| `producer.configured` | `producer`, `producer_id`, `config` | Triggered after a producer completes setup and becomes ready |

### Class-Level Usage Example

```ruby
# Subscribe to global producer lifecycle events
#{component}.monitor.subscribe('producer.configured') do |event|
  producer = event[:producer]
  puts "Producer configured: \#{producer.id}"

  # Example: Add middleware after producer is fully configured
  producer.middleware.append do |message|
    message
  end
end

# All producers will now trigger the above callback
producer = #{component}::Producer.new do |config|
  config.kafka = { 'bootstrap.servers': 'localhost:9092' }
end
```

For more details on class-level instrumentation patterns, see the [Monitoring and Logging](WaterDrop-Monitoring-and-Logging#global-cross-producer-monitoring) documentation.
MARKDOWN
    end

    # Write the file with explicit encoding
    File.write(output_file, content, encoding: 'utf-8')
  end
end

# Script execution
if __FILE__ == $0
  output_dir = ARGV[0] || DEFAULT_OUTPUT_DIR

  fetcher = InstrumentationFetcher.new(output_dir)
  fetcher.fetch_all
end

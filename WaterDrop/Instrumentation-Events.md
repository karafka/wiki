[//]: # (This file is auto-generated by bin/refresh_instrumentation_events)
[//]: # (Do not edit manually - changes will be overwritten)

# WaterDrop Instrumentation Events

This page lists all available instrumentation events for WaterDrop.

## Overview

WaterDrop uses a notification system that allows you to monitor and hook into various stages of message processing and producer operations. You can subscribe to any of these events to add custom monitoring, logging, or other functionality.

## Available Events

Below is the complete list of instrumentation events available in WaterDrop:


### Buffer Events

- `buffer.flushed_async`
- `buffer.flushed_sync`
- `buffer.purged`

### Error Events

- `error.occurred`

### Message Events

- `message.acknowledged`
- `message.buffered`
- `message.produced_async`
- `message.produced_sync`
- `message.purged`

### Messages Events

- `messages.buffered`
- `messages.produced_async`
- `messages.produced_sync`

### Oauthbearer Events

- `oauthbearer.token_refresh`

### Producer Events

- `producer.closed`
- `producer.closing`
- `producer.connected`
- `producer.disconnected`
- `producer.disconnecting`
- `producer.reload`
- `producer.reloaded`

### Statistics Events

- `statistics.emitted`

### Transaction Events

- `transaction.aborted`
- `transaction.committed`
- `transaction.finished`
- `transaction.marked_as_consumed`
- `transaction.started`

## Usage Example

To subscribe to any of these events, you can use the instrumentation monitor:

```ruby
WaterDrop::App.monitor.subscribe('event.name') do |event|
  # Your custom logic here
  puts "Event: #{event.id}"
  puts "Payload: #{event.payload}"
end
```

For more information about using instrumentation, please refer to the main documentation.

## Class-Level Events

WaterDrop also provides class-level instrumentation that allows you to monitor events across all producer instances. This is useful for external libraries and monitoring tools that need to hook into producer lifecycle events without requiring specific producer instance references.

### Available Class-Level Events


#### Connection_pool Events

- `connection_pool.created`
- `connection_pool.reload`
- `connection_pool.reloaded`
- `connection_pool.setup`
- `connection_pool.shutdown`

#### Producer Events

- `producer.configured`
- `producer.created`

### Class-Level Event Payloads

| Event | Payload Keys | Description |
|-------|--------------|-------------|
| `connection_pool.created` | `connection_pool`, `connection_pool_id` | Triggered when a new connection pool is created |
| `connection_pool.reload` | `connection_pool`, `connection_pool_id` | Triggered before a connection pool reloads its connections |
| `connection_pool.reloaded` | `connection_pool`, `connection_pool_id` | Triggered after a connection pool has reloaded its connections |
| `connection_pool.setup` | `connection_pool`, `connection_pool_id` | Triggered when a connection pool is being set up |
| `connection_pool.shutdown` | `connection_pool`, `connection_pool_id` | Triggered when a connection pool is shutting down |
| `producer.created` | `producer`, `producer_id` | Triggered when a new producer instance is instantiated, before configuration |
| `producer.configured` | `producer`, `producer_id`, `config` | Triggered after a producer completes setup and becomes ready |

### Class-Level Usage Example

```ruby
# Subscribe to global producer lifecycle events
WaterDrop.monitor.subscribe('producer.configured') do |event|
  producer = event[:producer]
  puts "Producer configured: #{producer.id}"

  # Example: Add middleware after producer is fully configured
  producer.middleware.append do |message|
    message
  end
end

# All producers will now trigger the above callback
producer = WaterDrop::Producer.new do |config|
  config.kafka = { 'bootstrap.servers': 'localhost:9092' }
end
```

For more details on class-level instrumentation patterns, see the [Monitoring and Logging](WaterDrop-Monitoring-and-Logging#global-cross-producer-monitoring) documentation.
